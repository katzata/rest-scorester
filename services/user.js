const { generateHash, validateHash } = require("../utils/encryption");
const { generateAccessToken, validateAccessToken, generateRefreshToken, validateRefreshToken } = require("../utils/jwt");
const { setResponseHeaders } = require("../utils/utils");

/**
 * Register a new user.
 * @param {Object} req The request object generated by "ExpressJs".
 * @param {Object} res The response object generated by "ExpressJs".
 */
async function register(req, res) {
    const { username, password } = req.body;
    const hashedPass = await generateHash(password);
    const userSettings = { "keepRecord": true };
    const gameSettings = {
        "numberOfPlayers": 1,
        "scoreBelowZero": false,
        "scoreTarget": 0,
        "mainTimer": false,
        "turnDuration": 0,
        "individualTimers": false,
        "editableFields": false
    };

    const query = { users: { username: req.body.username }};
    req.db.getEntry(query).then(queryRes => {
        if (queryRes[0] && queryRes[0].error) return catchDbErrors(req, queryRes[0].error);
        const exists = queryRes[0];

        if (!exists) {
            const users = {
                username,
                password: hashedPass,
                user_settings: JSON.stringify(userSettings),
                game_settings: JSON.stringify(gameSettings)
            };

            req.db.createEntry({ users }).then(createRes => {
                if (createRes[0] && createRes[0].error) return catchDbErrors(req, createRes[0].error);

                users["id"] = createRes.insertId;
                const { accessToken, refreshToken } = generateTokens(users);
                users["token"] = refreshToken;

                req.db.updateEntry(createRes.insertId, { users: { token: refreshToken } }).then(updateRes => {
                    if (updateRes[0] && updateRes[0].error) return catchDbErrors(req, updateRes[0].error);

                    setResponseHeaders(req, res, { accessToken, refreshToken });
                    setHTTPCookies(res, accessToken, refreshToken).then((tokenRes) => {
                        tokenRes
                            .status(201)
                            .send(prepareUserData(users, null, 4));
                    });
                });
            });
        } else {
            if (queryRes[0] && queryRes[0].error) return catchDbErrors(req, queryRes[0].error);

            setResponseHeaders(req, res)
                .send(JSON.stringify({ Errors: `The username ${username} is already registered`}, null, 4));
        };
    });
};

/**
 * Handle the user login and send the proper response.
 * @param {Object} req The request object generated by "ExpressJs";
 * @param {Object} res The response object generated by "ExpressJs";
 */
async function login(req, res) {
    const query = { users: { username: req.body.username }};

    req.db.getEntry(query).then(queryRes => {
        if (queryRes[0] && queryRes[0].error) return catchDbErrors(req, queryRes[0].error);

        const user = queryRes[0];

        if (user && user.id) {
            validatePassword(req.body.password, user.password).then((passCheckRes) => {
                if (passCheckRes) {
                    const userData = extractUserData(user);
                    const { accessToken, refreshToken } = generateTokens(user);

                    const updateData = { users: { token: refreshToken }};
                    req.db.updateEntry(userData.id, updateData).then(updateRes => {
                        if (updateRes[0] && updateRes[0].error) {
                            return catchDbErrors(req, updateRes[0].error);
                        };

                        setResponseHeaders(req, res, { accessToken, refreshToken })
                            .send(prepareUserData(userData, null, 4));
                    });
                } else {
                    req.errorHandling.sendErrors({ code: 409, list: ["Wrong username or password"]});
                };
            });
        } else {
            const errorMessage = user.error ? user.error : { code: 409, list: ["Wrong username or password"]};
            req.errorHandling.sendErrors(errorMessage);
        };
    });
};

/**
 * Handle the user logout.
 * @param {Object} req The request object generated by "ExpressJs";
 * @param {Object} res The response object generated by "ExpressJs";
 */
async function logout(req, res) {
    const { id } = validateToken(req.cookies.rToken);
    const updateData = { users: { token: "" } };

    req.db.updateEntry(id, updateData).then(updateRes => {
        if (updateRes[0] && updateRes[0].error) return catchDbErrors(req, updateRes[0].error)

        setResponseHeaders(req, res, { accessToken: "clear", refreshToken: "clear" })
            .status(201)
            .send(JSON.stringify({"res": "yay"}));
    });
};

/**
 * Check if the user is logged in.
 * @param {Object} req The request object generated by "ExpressJs";
 * @param {Object} res The response object generated by "ExpressJs";
 */
async function checkIfLogged(req, res) {
    const id = req.body && req.body.id ? req.body.id : null;

    if (id && req.cookies.rToken) {
        req.db.getEntry({ users: { id }}).then(queryRes => {
            if (queryRes[0] && queryRes[0].error) return catchDbErrors(req, queryRes[0].error);
            const { aToken, rToken } = req.cookies;

            if (rToken) {
                const user = extractUserData(queryRes[0]);
                const tokenData = validateToken(rToken);

                if (tokenData) {
                    setResponseHeaders(req, res)
                        .status(200)
                        .send(prepareUserData(user, null, 4));
                } else {
                    setResponseHeaders(req, res)
                        .status(200)
                        .send(JSON.stringify({error: "jwt expired"}));
                };
            };
        });
    };
};

/**
 * Updates the user data in the database.
 * @param {Object} data An object containing key value pairs representing the columns and values that will be updated.
 */
async function updateSettings(req, res) {
    const { url, body, cookies } = req;
    const { id } = validateToken(cookies.rToken);
    const query = {users: { id }};
    const column = url.slice(1);

    req.db.getEntry(query).then(getRes => {
        const userData = extractUserData(getRes[0]);

        if (userData) {
            for (let [setting, value] of Object.entries(body)) {
                if (value === "false") value = false;
                if (value === "true") value = true;

                userData[column][setting] = value;
            };

            const updatedData = { users: Object.fromEntries([[column.replace("S", "_s"), JSON.stringify(userData[column])]]) };

            req.db.updateEntry(id, updatedData).then(updateRes => {
                console.log(updateRes);
                const { changedRows } = updateRes;
                const response = changedRows ? { changedRows } : updateRes;
                
                setResponseHeaders(req, res).send(JSON.stringify(response));
            });
        };
    });
};

/**
 * Validates a passowrd.
 * @param {String} inputPass The password that needs to be validated.
 * @param {String} password The password hash that the password will be compared with.
 * @returns A boolean that indicates if the password is correct or not.
 */
async function validatePassword(inputPass, password) {
    return await validateHash(inputPass, password).then((passCheckRes) => passCheckRes);
};

/**
 * Generate the access and refresh JWT tokens.
 * @param {Object} user an object containing user data (id, username, etc.).
 * @returns An object containing two key value pairs that represent the access and refresh tokens and their respective values.
 */
function generateTokens(user) {
    const { id, username } = user;
    const accessToken = generateAccessToken({ id, username });
    const refreshToken = generateRefreshToken({ id, username, token: accessToken });

    return { accessToken, refreshToken };
};

/**
 * Validate refresh JWT token.
 * @param {String} user The JWT token.
 * @returns Either the decrypted data or null in case the token is not ok.
 */
 function validateToken(token) {
    const result = validateRefreshToken(token);
    return result && result.id ? result : null;
};


async function setHTTPCookies(res, accessToken, refreshToken) {
    const cookieOptions = {
        httpOnly: true,
        sameSite: "None",
        secure: true
    };

    return res.cookie(
        "aToken",
        accessToken, 
        { ...cookieOptions, maxAge: 0.25 * 60 * 60 * 1000 }
    )
    .cookie(
        "rToken",
        refreshToken,
        { ...cookieOptions, maxAge: 365 * 24 * 60 * 60 * 1000 }
    )
};

/**
 * Extracts the user data from the database response.
 * @param {Object} data Accepts an object contianing user data.
 * @returns An object with the properly formated user data.
 */
function extractUserData(data) {
    return {
        id: data.id,
        username: data.username,
        userSettings: JSON.parse(data.user_settings),
        gameSettings: JSON.parse(data.game_settings),
        token: data.token
    };
};

/**
 * Prepares the user data for the response.
 * @param {Object} data Accepts an object contianing user data.
 * @returns An object with the properly formated user data
 */
function prepareUserData(data) {
    return JSON.stringify({
        id: data.id,
        username: data.username,
        userSettings: data.userSettings,
        gameSettings: data.gameSettings
    });
};

/**
 * Catch and handle db errors.
 * @param {Object} req The request object generated by "ExpressJs".
 * @param {Object} error An object consisting of a single key value pair (code and list) which represent the error code and the errors list.
 */
function catchDbErrors(req, errors) {
    const { code, list } = errors;
    req.errorHandling.sendErrors({ code, list });
};

module.exports = () => (req, res, next) => {
    req.user = {
        register: (...params) => register(req, res, ...params),
        login: () => login(req, res),
        logout: () => logout(req, res),
        checkIfLogged: () => checkIfLogged(req, res),
        updateSettings: (...params) => updateSettings(req, res, ...params)
    };

    next();
};